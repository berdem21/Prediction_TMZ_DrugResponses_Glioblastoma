import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.linear_model import LinearRegression
import os

# ===============================================
# 1) READ EXCEL
# ===============================================
df = pd.read_excel("RESULTS_WH.xlsx", sheet_name="MTT")

# ===============================================
# 2) FIX SCALING
# ===============================================
result_cols = ["RESULT1", "RESULT2", "RESULT3"]

for col in result_cols:
    df[col] = df[col].astype(float)
    df.loc[df[col] > 1000, col] = df.loc[df[col] > 1000, col] / 1000.0

df["RESULT_AVG"] = df[result_cols].mean(axis=1)

# ===============================================
# 3) CREATE SAVE DIRECTORY
# ===============================================
save_dir = "WH_PLOTS"
os.makedirs(save_dir, exist_ok=True)

# ===============================================
# 4) FUNCTION: Plot & Predict
# ===============================================
def plot_and_predict(df_sub, title, save_name):

    plt.figure(figsize=(10, 6))
    doses = sorted(df_sub["TMZ DOSE"].unique())
    cmap = plt.get_cmap("tab10")

    for i, dose in enumerate(doses):

        df_dose = df_sub[df_sub["TMZ DOSE"] == dose].sort_values("SAAT")

        # --- Real data ---
        plt.plot(df_dose["SAAT"], df_dose["RESULT_AVG"],
                 marker="o", markersize=8, linewidth=2,
                 color=cmap(i), label=f"{dose} mg")

        # Regression
        X = df_dose[["SAAT"]].astype(float).values
        y = df_dose["RESULT_AVG"].values

        if len(df_dose) >= 2:
            model = LinearRegression()
            model.fit(X, y)

            future_hours = np.array([[96], [122], [144]])
            preds = model.predict(future_hours)

            # --- Prediction dotted line ---
            plt.plot(future_hours.flatten(), preds,
                     linestyle='--', linewidth=2, color=cmap(i))

            # --- Prediction points as DIAMOND markers ---
            plt.scatter(future_hours.flatten(), preds,
                        marker="D", s=70, color=cmap(i))

    # Formatting
    plt.title(title)
    plt.xlabel("Saat (h)")
    plt.ylabel("RESULT_AVG")
    plt.grid(True)
    plt.legend(title="TMZ Dozu")
    plt.tight_layout()

    # SAVE PLOT
    save_path = os.path.join(save_dir, f"{save_name}.png")
    plt.savefig(save_path, dpi=300)
    plt.close()

    print(f"Saved: {save_path}")

# ===============================================
# 5) SUBPLOT for 2D & 3D (same tumor type)
# ===============================================
def subplot_2D_3D(df_2d, df_3d, tumor_type):

    fig, axs = plt.subplots(1, 2, figsize=(15, 6))
    cmap = plt.get_cmap("tab10")

    for ax_idx, (df_sub, title) in enumerate([(df_2d, "2D"), (df_3d, "3D")]):

        doses = sorted(df_sub["TMZ DOSE"].unique())

        for i, dose in enumerate(doses):
            df_dose = df_sub[df_sub["TMZ DOSE"] == dose].sort_values("SAAT")

            # Real data
            axs[ax_idx].plot(df_dose["SAAT"], df_dose["RESULT_AVG"],
                             marker="o", markersize=8, linewidth=2,
                             color=cmap(i), label=f"{dose} mg")

            # Regression + predictions
            X = df_dose[["SAAT"]].astype(float).values
            y = df_dose["RESULT_AVG"].values

            if len(df_dose) >= 2:
                model = LinearRegression()
                model.fit(X, y)

                future_hours = np.array([[96], [122], [144]])
                preds = model.predict(future_hours)

                axs[ax_idx].plot(future_hours.flatten(), preds,
                                 linestyle='--', linewidth=2, color=cmap(i))

                axs[ax_idx].scatter(future_hours.flatten(), preds,
                                    marker="D", s=70, color=cmap(i))

        axs[ax_idx].set_title(f"{tumor_type} {title}")
        axs[ax_idx].set_xlabel("Saat (h)")
        axs[ax_idx].set_ylabel("RESULT_AVG")
        axs[ax_idx].grid(True)
        axs[ax_idx].legend(title="TMZ Dozu")

    fig.tight_layout()

    # Save subplot
    save_path = os.path.join(save_dir, f"{tumor_type}_2D_3D_subplot.png")
    fig.savefig(save_path, dpi=300)
    plt.close()

    print(f"Saved SUBPLOT: {save_path}")

# ===============================================
# 6) FILTER GROUPS
# ===============================================
df_A172_2D = df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "2D")]
df_A172_3D = df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "3D")]

df_U87_2D  = df[(df["Tümor Tipi"] == "U87") & (df["2D/3D"] == "2D")]
df_U87_3D  = df[(df["Tümor Tipi"] == "U87") & (df["2D/3D"] == "3D")]

# ===============================================
# 7) RUN NORMAL PLOTS
# ===============================================
plot_and_predict(df_A172_2D, "A172 2D", "A172_2D")
plot_and_predict(df_A172_3D, "A172 3D", "A172_3D")

plot_and_predict(df_U87_2D, "U87 2D", "U87_2D")
plot_and_predict(df_U87_3D, "U87 3D", "U87_3D")

# ===============================================
# 8) RUN SUBPLOT FIGURES
# ===============================================
subplot_2D_3D(df_A172_2D, df_A172_3D, "A172")
subplot_2D_3D(df_U87_2D, df_U87_3D, "U87")


# ===============================================
# 9) CREATE 2x2 FINAL COMBINED SUBPLOT (A172 + U87)
# ===============================================
def combine_subplots_2x2():

    # Load individual plot images
    img_A172_2D = mpimg.imread(os.path.join(save_dir, "A172_2D.png"))
    img_A172_3D = mpimg.imread(os.path.join(save_dir, "A172_3D.png"))
    img_U87_2D = mpimg.imread(os.path.join(save_dir, "U87_2D.png"))
    img_U87_3D = mpimg.imread(os.path.join(save_dir, "U87_3D.png"))

    # ---- Create 2x2 Figure ----
    fig, axs = plt.subplots(2, 2, figsize=(16, 12)) # Adjusted figsize for better display

    # List of axes, images, and titles
    panels = [
        (axs[0, 0], img_A172_2D, "A172 2D"),
        (axs[0, 1], img_A172_3D, "A172 3D"),
        (axs[1, 0], img_U87_2D, "U87 2D"),
        (axs[1, 1], img_U87_3D, "U87 3D")
    ]

    for ax, img, title in panels:
        ax.imshow(img)
        ax.axis("off")
        ax.set_title(title, fontsize=14)

        # --- Add dark blue border ---
        for spine in ax.spines.values():
            spine.set_edgecolor("#001a66")
            spine.set_linewidth(1.5)
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# --- Boşluk ayarları ---
fig.subplots_adjust(
    wspace=0.05,   # sağ–sol grafikler arası mesafe
    hspace=0.08    # alt–üst grafikler arası mesafe (öncekine göre azaltıldı)
)

# Çerçeve rengi ve kalınlığı
for ax_row in axes:
    for ax in ax_row:
        for spine in ax.spines.values():
            spine.set_edgecolor("navy")
            spine.set_linewidth(1.2)

    fig.tight_layout()

    final_path = os.path.join(save_dir, "A172_U87_COMBINED_2x2.png")
    fig.savefig(final_path, dpi=300)
    plt.close()

    print(f"Saved FINAL 2x2 COMBINED FIGURE WITH BORDER: {final_path}")

# Run it
combine_subplots_2x2()

# Second version v2: Negative predictions are clipped to zero

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.linear_model import LinearRegression

# =====================================
# 1) Read MTT sheet
# =====================================
df = pd.read_excel("RESULTS_WH.xlsx", sheet_name="MTT")

# =====================================
# 2) Fix scaling (values >1000 → /1000)
# =====================================
result_cols = ["RESULT1", "RESULT2", "RESULT3"]
for col in result_cols:
    df[col] = df[col].astype(float)
    df.loc[df[col] > 1000, col] = df.loc[df[col] > 1000, col] / 1000.0

# =====================================
# 3) Compute average
# =====================================
df["RESULT_AVG"] = df[result_cols].mean(axis=1)

# =====================================
# 4) Plot function for ONE panel
# =====================================
def plot_group(ax, df_sub, title):

    doses = sorted(df_sub["TMZ DOSE"].unique())
    cmap = plt.get_cmap("tab10")

    for i, dose in enumerate(doses):

        df_dose = df_sub[df_sub["TMZ DOSE"] == dose].sort_values("SAAT")

        # Measured values
        ax.plot(
            df_dose["SAAT"], df_dose["RESULT_AVG"],
            marker="o", linewidth=2, color=cmap(i),
            label=f"{dose} mg"
        )

        # Regression
        if len(df_dose) >= 2:
            X = df_dose[["SAAT"]].values
            y = df_dose["RESULT_AVG"].values

            model = LinearRegression()
            model.fit(X, y)

            future_hours = np.array([[96], [122], [144]])
            preds = model.predict(future_hours)

            #  Clip negative predictions to zero
            preds = np.maximum(preds, 0)

            ax.plot(
                future_hours.flatten(), preds,
                linestyle="--", marker="x", color=cmap(i)
            )

    ax.set_title(title)
    ax.set_xlabel("Time (h)")
    ax.set_ylabel("RESULT_AVG")
    ax.set_xlim(left=24)
    ax.set_ylim(bottom=0)
    ax.grid(True)

# =====================================
# 5) Filter groups
# =====================================
groups = [
    ("A172 2D", df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "2D")]),
    ("A172 3D", df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "3D")]),
    ("U87 2D",  df[(df["Tümor Tipi"] == "U87")  & (df["2D/3D"] == "2D")]),
    ("U87 3D",  df[(df["Tümor Tipi"] == "U87")  & (df["2D/3D"] == "3D")]),
]

# =====================================
# 6) Create combined 2×2 panel
# =====================================
fig, axes = plt.subplots(2, 2, figsize=(14, 12))
axes = axes.flatten()

for ax, (title, df_group) in zip(axes, groups):
    plot_group(ax, df_group, title)

# Shared legend
handles, labels = axes[0].get_legend_handles_labels()
fig.legend(
    handles, labels,
    title="TMZ Dose",
    loc="lower center",
    ncol=6,
    frameon=False
)

plt.tight_layout(rect=[0, 0.05, 1, 1])
plt.savefig("Combined_TimeCourse_With_Clipped_Predictions.png", dpi=300)
plt.show()


# Third version v2: calculating Prediction of 72th hour and accuracy

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

# =====================================
# 1) READ DATA
# =====================================
df = pd.read_excel("RESULTS_WH.xlsx", sheet_name="MTT")

# =====================================
# 2) FIX SCALING (values >1000 → /1000)
# =====================================
result_cols = ["RESULT1", "RESULT2", "RESULT3"]
for col in result_cols:
    df[col] = df[col].astype(float)
    df.loc[df[col] > 1000, col] = df.loc[df[col] > 1000, col] / 1000.0

# =====================================
# 3) COMPUTE AVERAGE RESULT
# =====================================
df["RESULT_AVG"] = df[result_cols].mean(axis=1)

# =====================================
# 4) FUNCTION: TRAIN (24+48) → PREDICT 72
# =====================================
def predict_72_and_accuracy(df_sub, group_name, results_list):

    real_vals = []
    pred_vals = []

    for dose in sorted(df_sub["TMZ DOSE"].unique()):
        df_dose = df_sub[df_sub["TMZ DOSE"] == dose]

        train = df_dose[df_dose["SAAT"].isin([24, 48])]
        test  = df_dose[df_dose["SAAT"] == 72]

        if len(train) == 2 and len(test) == 1:
            X_train = train[["SAAT"]].values
            y_train = train["RESULT_AVG"].values

            model = LinearRegression()
            model.fit(X_train, y_train)

            pred_72 = model.predict(np.array([[72]]))[0]
            real_72 = test["RESULT_AVG"].values[0]

            real_vals.append(real_72)
            pred_vals.append(pred_72)

    # Accuracy metrics
    r2 = r2_score(real_vals, pred_vals)
    mae = mean_absolute_error(real_vals, pred_vals)
    rmse = np.sqrt(mean_squared_error(real_vals, pred_vals))

    results_list.append({
        "Group": group_name,
        "R2_72h": r2,
        "MAE_72h": mae,
        "RMSE_72h": rmse
    })

    # =====================================
    # PLOT: REAL vs PREDICTED (72h)
    # =====================================
    plt.figure(figsize=(6, 6))
    plt.scatter(real_vals, pred_vals)
    min_val = min(real_vals + pred_vals)
    max_val = max(real_vals + pred_vals)
    plt.plot([min_val, max_val], [min_val, max_val])
    plt.xlabel("Real 72h RESULT_AVG")
    plt.ylabel("Predicted 72h RESULT_AVG")
    plt.title(f"{group_name} - Real vs Predicted (72h)")
    plt.grid(True)
    plt.tight_layout()
    plt.savefig(f"{group_name.replace(' ', '_')}_72h_prediction.png", dpi=300)
    plt.close()

# =====================================
# 5) FILTER GROUPS
# =====================================
groups = {
    "A172 2D": df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "2D")],
    "A172 3D": df[(df["Tümor Tipi"] == "A172") & (df["2D/3D"] == "3D")],
    "U87 2D":  df[(df["Tümor Tipi"] == "U87")  & (df["2D/3D"] == "2D")],
    "U87 3D":  df[(df["Tümor Tipi"] == "U87")  & (df["2D/3D"] == "3D")]
}

# =====================================
# 6) RUN ALL GROUPS
# =====================================
accuracy_results = []

for name, df_group in groups.items():
    predict_72_and_accuracy(df_group, name, accuracy_results)

# =====================================
# 7) SAVE COMBINED ACCURACY TABLE
# =====================================
accuracy_df = pd.DataFrame(accuracy_results)
accuracy_df.to_excel("Combined_72h_Prediction_Accuracy.xlsx", index=False)

print("\n=== Combined 72h Prediction Accuracy ===")
print(accuracy_df)
